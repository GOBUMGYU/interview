### Java의 특징

- Java는 객체지향 프로그래밍 언어이다.
- 기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어
- 장점
    - JVM(자바가상머신)위에서 동작하기 때문에 운영체제에 독립적이다.
    - GabageCollector를 통한 자동적인 메모리 관리가 가능하다.
- 단점
    - JVM위에서 동작하기 때문에 실행 속도가 상대적으로 느리다.
    - 다중 상속이나 타입에 엄격하며, 제약이 많다.

### JVM의 역활

JVM은 스택 기반으로 동작하며, Java Byte Code를 OS에 맞게 해석 해주는 역활을 하고 가비지 컬렉션을 통해 자동적인 메모리 관리를 해준다.

### Java의 컴파일 과정에 대해

- 개발자가 .java파일을 생성한다.
- build를 한다.
- java compiler의 javac의 명령어를 통해 바이트코드 .class를 생성한다.
- Class Loader를 통해 JVM메모리 내로 로드한다.

### Java에서 제공하는 원시 타입들은 무엇이고, 각각 몇바이트를 차지하나

- 정수형 byte, short, int, long 실수형 float, double 문자형 char 논리형 boolean
- 정수형   1,  2,  4,  8           실수형 4,  8      문자형  2    논리형 1 바이트를 차지

### 오버라이딩과 오버로딩에 대해

- 오버라이딩은 상위클래스에 있는 메소드를 하위 클래스에 재정의하는 것
- 오버로딩은 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메소드를 여러 개 정의하는 것을 말함

### 객체지향 프로그래밍 OOP에 대해 설명

프로그램 구현에 필요한 객체를 파악하고 상태와 행위를 가진 객체를 만들고 각각의 객체들의 역활이 무엇인지를 정의하여 객체들 간의 상호작용을 통해 프로그램을 만드는 것 

즉, 역활과 구현을 분리하는 것 특징으로는 캡슐화, 상속, 다형성, 추상화 등이 있고, 모듈 재사용으로 확장 및 유지보수가 용이

### try-with-resources 에 대해 설명

- try-with-resources는 try-catch-finally의 문제점을 보완하기 위해 나온개념
- try(…)안에 자원 객체를 전달하면, try블록이 끝나고 자동으로 자원을 해제 해주는 기능
- 따로 finally 구문이나 모든 catch구문에 종료 처리를 하지 않아도 되는 장점이있다고 함

### 불변 객체가 무엇인지 설명하고 대표적인 예시를 설명

- 불변 객체는 객체 생성 이후 내부의 상태가 변하지 않는 객체를 말함
- Java에서는 필드가 원시 타입인 경우 final 키워드를 사용해 불변 객체를 만들 수 있고,
- 참조 타입일 경우엔 추가적인 작업이 필요
    - 참조 타입은 대표적으로 객체를 참조할 수도 있고
    - 배열이나 List등을 참조할 수 있다.
    - 배열일 경우 배열을 받아 copy해서 저장하고, getter를 clone으로 반환하도록 하면 된다.
    - (배열을 그대로 참조하거나, 반환할 경우 외부에서 내부 값을 변경할 수 있음, 때문에  clone을 반환해 외부에서 값을 변경하지 못하게 함)
    - 리스트인 경우에도 배열과 마찬가지로 생성시 새로운 List를 만들어 값을 복사하도록 해야 한다.
    - 배열과 리스트는 내부를 복사하여 전달하는데, 이를 방어적 복사라고한다.
    

### 불변 객체나 final을 굳이 사용하는 이유

- Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
    - 공유자원이 불변이기 때문에 항상 동일한 값을 반환하기 때문)
- 실패 원자적인 메소드를 만들 수 있다.
    - 어떠한 예외가 발생하더라도 메소드 호출 전의 상태를 유지할 수 있어 예외 발생 전과 똑같은 상태로 다음 로직 처리 가능
- 부수 효과를 피해 오류를 최소하 할 수 있다.
    - 부수효과 : 변수의 값이 바뀌거나 객체의 필드 값을 설정하거나 예외나 오류가 발생하여 실행이 중단되는 현상
- 메소드 호출 시 파라미터 값이 변하지 않는다는 것을 보장할 수 있다.
- 가비지 컬렉션 성능을 높일 수 있다.
    - 가비지 컬렉터가 스캔하는 객체의 수가 줄기 때문에 Gc수행 시 지연시간도 줄어든다.

### 추상 클래스와 인터페이스를 설명하고, 차이에 대해 설명

- 추상 클래스는 클래스 내 추상 메소드가 하나 이상 포함되거나  abstract로 정의된 경우를 말하고
- 인터페이스는 모든 메소드가 추상 메소드로만 이루어져있는 것을 말함
- 공통점
    - new 연산자로 인스턴스 생성 불가능
    - 사용하기 위해서는 하위 클래스에서 확장/구현 해야 한다.
- 차이점
    - 인터페이스는 그 인터페이스를 구현하는 모든 클래스에 대해 특정한 메소드가 반드시 존재하도록 강제함이 있고,
    - 추상클래스는 상속받은 클래스들의 공통적인 로직을 추상화 시키고, 기능 확장을 위해 사용한다.
    - 추상클래스는 다중상속이 불가능하지만, 인터페이스는 다중상속이 가능하다.

### 싱글톤 패턴에 대해 설명

- 싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴
- 인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우와
- 동일한 인스턴스를 자주 생성해야 하는 경우에 주로 사용(메모리 낭비 방지)

### 싱글톤 패턴의 대표적인 예를 설명

- 싱글톤 패턴의 대표적인 예시는 Spring Bean 이다.
- 스프링의 빈 등록 방식은 기본적으로 싱글톤 스코프이고, 스프링 컨테이너는 모든 빈들을 싱글톤으로 관리
- 스프링은 요청할 때마다 새로운 객체를 생성해서 반환하는 기능도 제공 (프로토타입스코프)

### 가비지 컬렉션에 대해 설명

- 가비지 컬렉션은 JVM메모리 관리 기법 중 하나로 시스템에서 동적으로 할당했던 메모리 영역중 필요없어진 메모리 영역을 회수하여 메모리를 관리해주는 기법

### 가비지 컬렉션 과정에 대해 설명

- GC의 작업을 수행하기 위해 JVM이 애플리케이션의 실행을 잠시 멈추고, GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업을 중단 후 (Stop The World 과정) 사용하지 않는 메모리를 제거하고 작업이 재개된다.

### 객체 지향의 설계원칙 solid

- SRP - 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 한다.
- OCP - 개방 폐쇠 원칙 : 확장에만 열려있고, 변경에는 닫혀있어야 한다.
    - 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요
- LSP - 리스코프 치환 원칙 : 프로그램의 정확성을 깨트리지 않으면서 상위 타입은 항상 하위 타입의 인스턴스로 대체할 수 있어야 한다.
    - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면, 이 원칙이 필요
- ISP - 인터페이스 분리 원칙 : 인터페이스 내에 메소드는 최소화 일수록 좋다(하나의 인터페이스 보다 여러 개의 구체적인 인터페이스가 낫다.)
    - 인터페이스가 명확해지고, 대체 가능성이 높아진다.
- DIP - 의존관계 역전 원칙 : 역활(인터페이스)에 의존해야 한다. 구체화에 의존하면 변경이 아주 어려워진다.

### 자바의 메모리 영역에 대해 설명

- 자바의 메모리 공간은 크게 Method 영역, Stack 영역, Heap 영역으로 구분되고, 데이터 타입에 따라 할당된다.
- 메소드(Method) 영역 : 전역변수와 static변수를 저장하며, Method영역은 프로그램의 시작부터 종료까지 메모리에 남아있다.
- 스택(Stack) 영역 : 지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제된다. LIFO Last In First Out구조를 갖고 변수에 새로운 데이터가 할당되면 이전 데이터는 지워진다.
- 힙(Heap) 영역 : new 키워드로 생성되는 객체(인스턴스), 배열 등이 Heap영역에 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.

### 각 메모리 영역이 할당되는 시점

- Method : JVM이 동작해서 클래스가 로딩될 때 생성
- Stack : 컴파일 타임 시 할당
    - 컴파일 타임 : 소스코드가 기계어로 변환되어 실행가능한 프로그램이 되는 과정
- Heap : 런타임시 할당
    - 런타임 : 컴파일 타임 이후 프로그램이 실행되는 때

### 클래스와 객체에 대해 설명

클래스는 객체를 만들어내기 위한 설계도 혹은 틀 이라고 할 수 있고, 객체를 생성하는데 사용

객체는 설계도(클래스)를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖는다.

여기서 상태는 필드, 행동은 메소드라고 표현

객체에 메모리가 할당되어 실제로 활용되는 실체는 인스턴스라고 부른다.

### 생성자에 대해 설명

- 명시적으로 생성자를 만들지 않아도 default로 만들어지며, 생성자는 파라미터를 다르게하여 오버로딩 할 수 있다.
- 생성자는 이름은 클래스 이름과 같아야 한다.
- 생성자는 리턴형이 없다, 객체 초기화가 목적
- 생성자는 객체 생성시 호출된다.
### Wrapper Class란 무엇이며, Boxing과 UnBoxing는 무엇인지 설명

- 기본자료형(Primitive data type)에 대한 객체 표현을 Wrapper class라고 한다.
- 기본 자료형 → Wrapper class로 변환하는 것을 Boxing이라 하며,
- Wrapper class → 기본자료형으로 변환하는 것을 UnBoxing이라 한다.

### Synchronized에 대해 설명

- 여러 개의 쓰레드가 한개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외하고 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념
- 데이터의 thread-safe를 하기 위해 자바에서 Synchronized 키워드를 제공해 멀티 쓰레드 환경에서 쓰레드간 동기화를 시켜 데이터의 thread-safe를 보장한다.
- Synchronized는 변수와 메소드에 사용해서 동기화 할 수 있으며, Synchronized를 남발하면 오히려 프로그램의 성능저하를 일으킬 수 있다.

### new String()고 리터럴(””)의 차이에 대해 설명

- new String()는 new 키워드로 새로운 객체를 생성하기 때문에 Heap메모리 영역에 저장되고 ,
- “”는 Heap안에 있는 String Constant Pool 영역에 저장된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3fcb9e04-920e-4e18-9e71-2c322686fe67/Untitled.png)

### String, StringBuffer, StringBuilder의 차이를 설명

- String은 불변의 속성을 가지며, StringBuffer와 StringBuilder는 가변의 속성을 가진다.
- StringBuffer는 동기화를 지원하여 멀티 쓰레드 환경에서 주로 사용하며,
- StringBuilder는 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용한다.

### String 객체가 불변인 이유에 대해 설명

- 캐싱 기능에 의한 메모리 절약과 속도 향상
    - Java에서 String 객체들은 Heap의 String Pool 이라는 공간에 저장되는데, 참조하려는 문자열이 String Pool에 존재하는 경우 새로 생성하지 않고 Pool에 있는 객체를 사용하기 때문에 특정 문자열 값을 재사용하는 빈도가 높을 수록 상당한 성능 향상을 기대할 수 있다.
- thread-safe
    - String 객체는 불변이기 때문에 여러 쓰레드에서 동시에 특정 String 객체를 참조하더라도 안전하다.
- 보안기능
    - 중요한 데이터를 문자열로 다루는 경우 강제로 해당 참조에 대한 문자열 값을 바꾸는 것이 불가능하기 때문에 보안에 유리
    

### 접근 제한자에 대해 설명

- 변수 또는 메소드의 접근 범위를 설정해주기 위해서 사용하는 자바의 예약어를 의미하고 총 4가지가 있다.
- public - 접근제한이 없다. (같은 프로젝트 내 어디서든 사용 가능)
- protected - 해당 패키지 내 접근 가능,패키지가 다르더라도 다른 패키지에서 상속받아 자손 클래스에서 접근 가능
- default - 해당 패키지 내에서만 접근 가능
- private - 해당 클래스에서만 접근 가능

### 클래스 멤버 변수 초기화 순서에 대해 설명

- static 변수 선언부 : 클래스가 로드 될 때 변수가 제일 먼저 초기화 된다.
- 필드 변수 선언부 : 객체가 생성될 때 생성자 block보다 앞서 초기화 된다.
- 생성자 block : 객체가 생성될 때 JVM이 내부적으로 locking(thread-safe)영역

### static 에 대해 설명

- static 키워드를 사용한 변수나 메소드는 클래스가 메모리에 올라갈 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용할 수 있다. 즉, 인스턴스(객체) 생성 없이 바로 사용 가능
- 모든 객체가 메모리를 공유한다는 특징이 있고, GC관리 영역 밖에 있기 때문에 프로그램이 종료 될 때 까지 메모리에 값이 유지된 채로 존재하게 된다.

### static을 사용하는 이유에 대해 설명

- static는 자주 변하지 않는 값이나 공통으로 사용되는 값 같은 공용자원에 대한 접근에 있어서 매번 메모리에 로딩하거나 값을 읽어들이는 것보다 일종의 전역변수와 같은 개념을 통해 접근하는 것이 비용도 줄이고 효율을 높일 수 있다.
- 인스턴스  생성 없이 바로 사용 가능하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리할 때 용이

### Inner Class(내부 클래스)의 장점에 대해 설명

- 내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있다.
- 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 코드의 캡슐화를 증가시킨다.
- 외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 복잡성을 줄일 수 있다.

### 리플렉션이란 무엇인지 설명

- 리플렉션이란 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API

### 리플렉션은 어떤 경우에 사용되는지 설명

코드를 작성할 시점에 어떤 타입의 클래스를 사용할지 모르지만, 런타임 시점에 지금 실행되고 있는 클래스를 가져와서 실행해야 하는 경우 사용된다.

프레임워크나 IDE에서 이런 동적인 바인딩을 이용한 기능을 제공, intellij의 자동완성 기능, 스프링의 애노테이션이 리플렉션을 이용한 기능이라고 할 수 있다.

### Error와 Exception의 차이를 설명

- Error는 실행 중 일어날 수 있는 치명적 오류를 말함. 컴파일 시점에 체크할 수 없고, 오류가 발생하면 프로그램은 비정상 종료되며 예측 불가능한 UncheckedException에 속함
- 반면, Exception은 Error보다 비교적 경미한 오류이며, try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있다.

### CheckedException과 UnCheckedException의 차이를 설명

- CheckException은 실행하기 전에 예측 가능한 예외를 말하고, 반드시 예외 처리를 해야 한다.
    - 대표적인 Exception - IOException, ClassNotFoundExcpeiton 등
- UncheckedException은 실행하고 난 후 알 수 있는 예외를 말하고, 따로 예외처리를 하지 않아도 된다.
    - 대표적인 Exception - NullPointerException, ArrayIndexOutOfBoundException 등
- RuntimeException은 UncheckedException을 상속한 클래스이고, RuntimeException이 아닌 것은 CheckedException을 상속한 클래스이다.

### Optional API에 대해 설명

개발할때 가장 많이 발생하는 예외 중 하나가 NullPointerException이다

NPE를 피하려면 null여부 검사를 필연적으로 하게 되는데 만약 null검사를 해야하는 변수가 많은 경우 코드가 복잡해지고 번거롭다. 하지만 Java8 부터 Optional<T>를 제공하여 null로 인한 예외가 발생하지 않도록 도와주고, Optional 클래스의 메소드를 통해 null을 컨트롤 할 수 있다.

### 컬렉션 프레임워크에 대해 설명

- 다수의 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미
- 자바 컬렉션에는 List, Set, Map 인터페이스를 기준으로 여러 구현체가 존재하고, 이에 더해 Stack, Queue인터페이스도 존재

### List, Set, Map, Stack, Queue의 특징에 대해 설명

- List는 순서가 있는 데이터 집합, 데이터의 중복을 허용, 대표적인 구현체로는 ArrayList가 있고, 이는 Vector를 개선한 것 이외에도 LinkedList가 있다.
    - Vector, ArrayList, LinkedList, Stack, Queue
- Set은 순서가 없는 데이터의 집합, 데이터의 중복을 허용하지 않는다. 대표적인 구현체로는 HashSet이 있고, 순서를 보장하기 위해서는 LinkedHashSet을 사용(Map의 key-value구조에서 key대신 value가 들어가 value를 key로 하는 자료구조)
    - HashSet, LinkedHashSet, TreeSet
- Map은 키와 값이 한 쌍으로 이뤄져 있고, 키를 기준으로 중복을 허용하지 않으며, 순서가 없다. key의 순서를 보장하기 위해서는 LinkedHashMap을 사용
    - HashMap, TreeMap, HashTable, Properties
- Stack 객체는 직접 new키워드로 사용할 수 있으며, Queue 인터페이스는 LinkedList에 new 키워드를 적용해 사용할 수 있다.

### Set과 Map의 타입이 Wrapper Class가 아닌 Object를 받을 때 중복검사를 어떻게 할건지 설명

hashCode() 메소드를 오버라이딩 하여 리턴된 해시코드 값이 같은지를 보고 해시코드 값이 다르다면 다른 객체로 판단하고, 해시코드 값이 같으면 equals()메소드를 오버라이딩하여 다시 비교 이 두 개가 모두 맞으면 중복객체 

 

### Vector와 List의 차이를 설명

- 벡터는 데이터 삽입시 원소를 밀어내지만 리스트는 노드를 연결만 하기 때문에, 삽입 삭제 부분에서 리스트가 시간복잡도의 우위를 가진다.
- 벡터는 랜덤부분접근이 가능하지만 리스트는 더블링크드리스트(노드가 양쪽으로 연결)로 되어 있기 때문에 랜덤 접근이 되지 않는다. 검색적인 측면에서는 벡터가 우위를 가진다.
- 벡터는 리스트와 달리 항상 동기화되는 장점이자 단점을 가지고 있다. 멀티 쓰레드 환경에서 객체를 추가하고 삭제할 수 있지만, 단일 쓰레드 환경 일때도 동기화를 하기 때문에 List보다 성능이 떨어진다.

### 제네릭에 대해 설명하고, 왜 쓰는지 설명

- 제네릭은 데이터 타입을 하나로 지정하지 않고 사용할 때마다 범용적이고 포괄적으로 지정한다는 의미
- 제네릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있어 에러를 사전에 방지할 수 있다.

### final / finally / finalize의 차이를 설명

- final은 클래스, 메소드, 변수, 인자를 선언할 때 사용할 수 있으며, 한 번만 할당하고 싶을 때 사용
    - final 변수는 한 번 초기화되면 그 이후에 변경할 수 없다.
    - final 메소드는 다른 클래스가 이 클래스를 상속할 때 메소드 오버라이딩을 금지한다.
    - final 클래스는 다른 클래스에서 이 클래스를 상속할 수 없다.
- finally는 try-catch와 사용되며 try-catch가 종료될 때 finally block이 항상 수행되기 때문에 마무리 작업이 존재하는 경우에 해당하는 코드를 작성해주는 코드 블록
- finalize는 Object클래스에 정의되어 있는 메소드이며 GC에 의해 호출되는 메소드로 절대 호출 해서는 안되는 메소드이다. GC가 발생하는 시점이 불분명하기 때문에  해당 메소드가 실행된다는 보장이 없고, finalize()메소드가 오버라이딩 되어 있으면 GC가 이루어질 때 바로 Garbage Collectiong 되지 않는다. GC가 지연되면서 OOME(Out of Memory Exception) 이 발생할 수 있기 때문에 finalize()메소드를 오버라이딩하여 구현하는 것을 권장하지 않는다.

### 직렬화(Serialize)에 대해 설명

- 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술이며, 반대로 직렬화된 바이트 형태의 데이터로 다시 객체로 변환하는 기술이 역직렬화 라고 한다.
- 간단히 JVM의 메모리에 상주(힙 or 스택) 되어 있는 객체 데이터를 바이트 형태로 변환하는 기술

### SerialVersionUID를 선언해야 하는 이유에 대해 설명

- JVM은 직렬화와 역직렬화 하는 시점의 클래스에 대한 버전 번호를 부여하는데, 만약 그 시점에 클래스 정의가 바뀌어 있다면 새로운 버전 번호를 할당하게 된다. 그래서 직렬화할 때의 버전 번호와 역직렬화할 때의 버전 번호가 다르면 역직렬화가 불가능하게 될 수 있기 때문에 이런 문제를 해결하기 위해 SerialVersionUID를 사용
- 만약 직렬화 할 때 사용한  SerialVersionUID의 값과 역직렬화 하기 위해 사용했던 SerialVersionUID의 값이 다르면 InvaildClassException이 발생 할 수 있다.

### 추가 1
힙 메모리에 메모리가 할당 되는 것을 레퍼런스 자료형이라 한다.

### 추가 2
추상메서드는 상속 받아서 오버라이딩 해야 한다.

### 추가 3
일반클래스 : 내용있는 메서드만 존재
추상클래스 : 내용있는 메서드도 있고, 추상메서드도 있다.
인터페이스 : 모든 메서드는 추상 메서드이다.

### 추가 4
Throwable
↑
Compile Exception
IOException
FileNotFoundException  
classNotFoundException
↑
Runtime Exception
ArrayIndexOutOfBoundsException : 배열 예외 발생
NumberFormatException : 숫자가 아닐때 발생하는 예외
ArithmeticException : 연산 예외

예외 처리는 왜 해야 하나 ? 자바에서 제공되는 클래스 들

프로그램에서의 오류

컴파일 오류 (compile error)

- 프로그램 코드 작성 중 발생하는 문법적 오류
- 최근에는 개발환경(eclipse)에서 대부분의 컴파일 오류는 detection 됨
  실행오류 (runtime error)
- 실행 중인 프로그램이 의도하지 않은 동작(bug)을 하거나 프로그램이 중지 되는 오류
- 실행 오류는 비정상 종료가 되는 경우 시스템의 심각한 장애를 발생할 수 있음

예외 처리의 중요성

- 프로그램의 비정상 종료를 피하여 시스템이 원활이 실행되도록 함
- 실행 오류가 발생한 경우 오류의 과정을 재현하는 것은 현실적으로 힘들다
- 오류가 발생한 경우 log를 남겨서 추후 log분석을 통해 그 원인을 파악하여 bug를 수정하는 것이 중요

오류와 예외 클래스

- 시스템 오류(error) : 가상 머신에서 발생, 프로그래머가 처리 할 수 없는 오류임
  동적 메모리가 없는경우, 스택메모리 오버플로우 등
- 예외(Exception) : 프로그램에서 제어 할 수 있는 오류
  읽어들이려는 파일이 존재하지 않거나, 네트웍이나 DB연결이 안되는 경우 등
- 자바는 안전성이 중요한 언어로 대부분 프로그램에서 발생하는 오류에 대해 문법적으로 예외 처리를 해야함

예외 클래스들

- 모든 예외 클래스의 최상위 클래스는 Exception 클래스 Object - > Throwable -> Exception
- 자바에서는 다양한 예외들에 대해 그 처리를 위한 클래스가 제공되고 있음
- Arithmetic Exception : 정수를 0으로 나눈 경우 발생 RuntimeException 하위 크래스임
- NullPointerException : 초기화 되지 않은 Object를 사용하는 경우
  Dog d = null;
  System.out.println(dog);;
- SocketException : IOException 하위 클래스임
- ArrayIndexOutOfBoundsException : 배열의 크기를 넘어선 위치를 참조하려는 경우 RuntimeException 하위 크래스임
- FileNotFoundException : 참조하는 파일이 지정된 위치에 존재하지 않는 경우 IOException 하위 클래스임
- ClassNotFoundException :
  class.forName("sis.studentinfo.Student"); //클래스가 로드되지 않는 경우
- InterruptedException : Thread.sleep(), join().Object의 wait()로 non-runnable 상태인 thread를 runnable하게 만들 수 있도록 사용할 수 있음

### 추가 5
- HashMap의 경우 스레드(동기화)를 지원하지 않는다.
- 다중 스레드 환경에서 Hashtable은 동기화를 지원
- Vector 자동 동기화를 스레드 기능이있다. — 채팅
  - 동시접속 = 동시실행 했을 때 충돌되지 않도록 스케쥴링을 해준다.
- Hashtable 클래스 : 검색이 빠름(검색이 용이) 스레드 기능이있다.
- Hashset : 중복 허용
- ArratyList 중복 허용안함