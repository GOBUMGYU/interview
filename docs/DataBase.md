### 데이터베이스의 특징에 대해 설명

- 실시간 접근성(Real-Time Accessibility) : 비정형적인 질의(조회)에 대하여 실시간 처리에 의한 응답이 가능해야 한다.
- 지속적인 변화(Continuous Evloution) : 데이터베이스의 상태는 동적이다. 즉 새로운 데이터 의 갑입 (Insert), 삭제(Delete), 갱신(Update)으로 항상 최신의 데이터를 유지해야 한다.
- 동시공용(Concurrent Sharing) : 데이터베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것이므로 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 한다.
- 내용에 의한 참조(Content Reference) : 데이터베이스에 있는 데이터를 참조할 때 데이터 레코드의 주소나 위치에 의해서가 아니라 사용자가 요구하는 데이터 내용으로 찾는다.

### 데이터베이스 언어(DDL, DML, DCL)에 대해 설명

- DDL(정의어 : Data Definition Language) 데이터베이스 구조를 정의, 수정, 삭제하는 언어 (alter, create, drop)
- DML(조작어 : Data Munipulation Language) : 데이터베이스내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어 (select, insert, update, delete)
- DCL(제어어 : Data Control Language) : 데이터에 대해 무결성 유지, 병행 수행 제어, 보호와 관리를 위한 언어(commit, rollback, grant, revoke)

### Select 쿼리의 수행 순서를 알려주세요

FROM, ON, JOIN > WHERE, GROUP BY, HAVING > SELECT >DISTINCT, ORDER BY > LIMIT

- FROM : 각 테이블을 확인
- ON : JOIN 조건을 확인
- JOIN : JOIN이 실행되어 데이터가 SET으로 모아지게 된다. 서브쿼리도 함꼐 포함되어 임시 테이블을 만들 수 있게 도와준다.
- WHERE : 데이터셋을 형성하게 되면 WHERE의 조건이 개별 행에 적용된다. WHERE 절의 제약 조건은 FROM절로 가져온 테이블에 적용될 수 있다.
- GROUP BY : WHERE의 조건 적용 후 나머지 행은 GROUP BY절에 지정된 열의 공통 값을 기준으로 그룹화한다. 쿼리에 집계 기능이 있는 경우에만 이 기능을 사용해야 한다.
- HAVING : GROUP BY절이 쿼리에 있을 경우 HAVING절의 제약조건이 그룹화된 행에 적용된다.
- SELECT : SELECT에 표현된 식이 마지막으로 적용된다.
- DISTINCT : 표현된 행에서 중복된 행은 삭제
- ORDER BY : 지정된 데이터를 기준으로 오름차순, 내림차순으로 지정
- LIMIT : LIMIT에서 벗어나는 행들은 제외되어 출력

### 트리거(Trigger)에 대해 설명

- 트리거는 특정 테이블에 대한 이벤트에 반응해 INSERT, DELETE, UPDATE같은 DML문이 수행되었을 때, 데이터베이스를 자동으로 동작하도록 작성된 프로그램이다.
- 사용자가 직접 호출하는 것이 아닌, 데이터베이스에서 자동적으로 호출한다는 것이 특징

### Index에 대해 설명하고 장/단점에 대해 설명

- Index란 테이블을 처음부터 끝까지 검색하는 방법인 FTS(Full Table Scan)과는 달리 인덱스를 검색하여 해당 자료의 테이블에 엑세스 하는 방법이다.
    - 예를 들어, DB를 책으로 비유하면 데이터는 책의 내용일 것이고, 데이터가 저장된 레코드의 주소는 index목록에 있는 페이지 번호일 것
- 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 검색하는데는 빠르지만, 새로운 값을 추가하거나, 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다.
- 즉, 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 검색 속도를 높이는 기능이라고 볼 수 있다.

### DBMS는 Index를 어떻게 관리하고 있는가?

- B+ Tree인덱스 자료구조
    - 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이며,
    - BTree 리프노드들은 LinkdedList로 연결하여 순차 검색을 용이하게 한다. 해시 테이블보다 나쁜 O(log2N)의 시간복잡도를 갖지만 일반적으로 사용되는 자료구조이다.
- 해시테이블
    - 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현
    - 시간복잡도가 0(1)이라 검색이 매우 빠르다.
    - 부등호(<,>)와 같은 연속적인 데이터를 위한 순차 검색이 불가능하기 때문에 사용에 적합하지 않다.

### 정규화에 대해 설명

하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이며, 데이터의 일관성, 최소한의 중복, 최대한의 데이터 유연선을 위한 방법

- 제1 정규형 : 테이블의 컬럼이 원자 값(Atomic Value: 하나의 값)을 갖도록 분해한다.
- 제2 정규형 : 제 1정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해한다.
    - 완전함수종속 : 기본키의 부분집합이 다른 값을 결정하지 않는 것을 의미
- 제3 정규형 : 제 2정규형을 만족하고, 이행적 함수 종속을 없애도록 분해한다.
    - 이행적종속 : A → B, B → C가 성립할 때 A → C가 성립되는 것을 의미
- BCNF 정규형 : 제 3정규형을 만족하고, 함수 종속성 X → Y가 성립할 때 모든  결정자 X가 후보키가 되도록 분해한다.



### 정규화 장/단점

- 장점
    - 데이터베이스 변경 시 이상현상이 발생하는 문제점을 해결할 수 있다.
    - 데이터베이스 구조 확장 시 정규화된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.
- 단점
    - 릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN연산)이 많아진다. 이로인해 질의에 대한 응답 시간이 느려질 수 있다.

정규화를 수행한다는 것은 이상현상을 제거하는 것이다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다. 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨리질 수도 있고, 느려질 수 도 있는 특성이 있다.

### 역정규화를 하는 이유에 대해 설명

정규화를 거치면 릴레이션 간의 연산(JOIN 연산)이 많아지는데, 이로인해 성능이 저하 될 우려가 있따. 역정규화를 하는 가장 큰이유는 성능 문제가 있는(읽기작업이 많이 필요한) DB의 전반적인 성능을 향상시키기 위함이다.

### 이상 현상의 종류에 대해 설명

- 이상 현상은 테이블을 설계할 때 잘못 설계하여 데이터를 삽입, 삭제, 수정할 때 생기는 논리적 오류를 말한다.
    - 삽입 이상 : 자료를 삽입할 때 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상
    - 갱신 이상 : 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상
    - 삭제 이상 : 어떤 정보를 삭제하면, 의도하지 않은 다른 정보까지 삭제되어버리는 현상
- 이러한 이상 현상을 예방하고 효과적인 연산을 하기 위해 데이터 정규화를 한다.

### SQL Injection이 무엇인지 설명

SQL Injection이란 공격자가 악의적인 의도를 갖는 SQL구문을 삽입하여 데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격 기법이다.

### SQL Injection을 방버 및 방지하기 위한 방법

- 입력값을 검증하여 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우 입력된 값이 개발자가 의도한 값(유효값)인지 검증
- 저장 프로시저를 사용
    - 저장 프로시저란 사용하고자 하는 Query에 미리 형식을 지정하는 것을 말한다. 지정된 형식의 데이터가 아니면 Query가 실행되지 않기 때문에 보안성이 크게 향상

### 트랜잭션이란 무엇인가

- 트랜잭션은 작업의 완전성을 보장해준다.
- 즉, 작업들을 모두 처리하거나 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능
- 하나의 트랜잭션은 Commit(작업완료) 되거나 Rollback(취소) 된다.

### 트랜잭션의 특성(ACID)에 대해 설명

- 원자성(Atomicity) : 작업이 모두 반영되던지 아니면 전혀 반영되지 않아야 한다.
- 일관성(Consistency) : 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 한다.
- 독립성(Isolation) : 둘 이상의 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다.
- 영속성(Durability) : 완료된 결과는 영구적으로 반영되어야 한다.

### DB락에 대해 설명

- DB Lock는 트랜잭션 처리의 순차성을 보장하기 위한 방법
- 공유락(LS, Shared Lock) : Read Lock라고도 하는 공유락은 트랜잭션이 읽기를 할 때 사용하는 락이며, 데이터를 읽기만하기 때문에 같은 공유락 끼리도 동시에 접근이 가능
- 베타락(LX, Exclusive Lock) : Write Lock라고도 하는 베타락은 데이터를 변경할 때 사용하는 락 트랜잭션이 완료될 때까지 유지되며, 베타락이 끝나기 전까지 어떠한 접근도 허용하지 않는다.

### 옵티마이저(Optimizer)대해 아는대로 설명

- 옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS내부의 핵심 엔진이다.
- 컴퓨터의 두뇌가 CPU인 것 처럼 DBMS의 두뇌는 옵티마이저라고 할 수 있다. 개발자가 SQL을 작성하고 실행하면 즉시 실행되는 것이 아니라 옵티마이저라는 곳에서 “이 쿼리문은 어떻게 실행 시키겠다”라는 여러가지 실행 계획을 세우고, 최고의 효율을 갖는 실행계획을 판별 후 그 실행계획에 따라 쿼리를 수행하게 되는 것이다.

### DB튜닝(Tuning)이 무엇인지 그리고 튜닝의 3단계에 대해 설명

- DB튜닝이란 DB의 구조나, DB자체, 운영체제 등을 조정하여 DB시스템의 전체적인 성능을 개선한느 작업을 말함
- 튜닝은 DB설계 튜닝 → DBMS 튜닝 → SQL튜닝 단계로 진행할 수 있다.
- 1단계 - DB 튜닝(모델링 관점)
    - DB설계 단계에서 성능을 고려하여 설계
    - 데이터 모델링, 인덱스 설계
    - 데이터파일, 테이블 스페이스 설계
    - 데이터베이스 용량 산정
    - 예) - 반정규화, 분산파일배치
- 2단계 - DBMS튜닝(환경 관점)
    - 성능을 고려하여 메모리나 블록 크기 지정
    - CPU, 메모리 I/O에 관한 관점
    - 예) - Buffer크기, Cache 크기
- 3단계 - SQL 튜닝 (App관점)
    - SQL작성 시 성능 고려
    - Join, Indexing, SQL Execution Plan
    - 예) - Hash / Join

### Inner join과 Outer join의 차이를 설명

- Inner Join은 서로 연관된 내용만 검색하는 조인 방법
    - A와 B에 대해 수행하는 것은, A와 B의 교집합을 말함. 벤다이어그램으로 그렸을 때 교차되는 부분을 말함.
- Outer join은 한쪽에는 데이터가 있고 한 쪽에는 데이터가 없는 경우, 데이터가 있는 쪽의 내용을전부 출력하는 방법
    - A와 B에 대해 수행하는 것은 A와 B의 합집합을 말함. 벤 다이어그램을 그렸을 때 합집합을 의미

![image](https://user-images.githubusercontent.com/106207558/230920066-e2de0a4f-7176-43ba-99fb-d583140fa1ea.png)


### Group By의 역활에 대해 설명

- Group By는 Group By명령어를 통해 특정 컬럼을 기준으로 연산한 결과를 집계 키로 정의하여 그룹을 짓는 역활을 말함
- 집합 연산자는 COUNT, SUM, AVG, MAX, MIN등이 있고, Distinct와 같이 중복 데이터를 제거하는 특징이 있다.

### DELETE, TRUNCATE, DROP의 차이

- DELETE는 데이터를 지우지만 테이블 용량은 줄어들지 않고 원하는 데이터만 골라서 지울 수 있다. 삭제 후 되돌릴 수 있다.

- TRUNCATE는 전체 데이터를 한번에 삭제하는 방식, 테이블 용량이 줄어들고 인덱스 등도 삭제되지만 테이블은 삭제할 수 없고, 삭제 후 되돌릴 수 없다.

- DROP은 테이블 자체를 완전히 삭제(공간, 인덱스, 객체 모두 삭제) 삭제 후 되돌릴 수 없다.

### 데이터베이스 클러스터링과 리플리케이션의 차이에 대해 설명

클러스터링이란 여러 개의 DB를 수평적인 구조로 구축하는 방식, 동기 방식으로 사용되며, 다음과 같은 장단점이 있다.

- 장점
    - DB간의 데이터를 동기화하여 항상 일관성있는 데이터를 얻을 수 있다.
    - 1개의 DB가 죽어도 다른 DB가 살아 있어 시스템을 장애없이 운영할 수 있다. (높은 가용성)
    - 기존에 하나의 서버에 몰리던 부하를 여러 곳으로 분산시킬 수 있다.(로드밸런싱)
- 단점
    - 저장소 하나를 공유하면 병목현상이 발생할 수 있다.
    - 병목현상 : 전체 시스템이 성능이나 용량이 하나의 구성요소로 인해 제한을 받는 현상
    - 서버를 동시에 운영하기 위한 비용이 많이 든다.

리플리케이션은 여러개의 DB를 권한에 따라 수직적인 구조로 구축하는 방식. 비동기 방식으로 사용되며, 다음과 같은 장단점이 있다.

- 장점
    - DB 요청의 60% ~ 80% 정도가 읽기 작업이기 때문에 Replication만으로도 충분히 성능을 높일 수 있다. 비동기 방식으로 운영되어 지연 시간이 거의 없다.
- 단점
    - 노드들 간 데이터 동기화가 보장되지 않아 일관성있는 데이터를 얻지 못할 수 있다.
    - Master DB가 다운되면 복구 및 대처가 까다롭다.


### HAVING과 WHERE의 차이를 설명

having는 그룹을 필터링 하는데 사용되고, where은 개별행을 필터링하는데 사용

집계 함수(Count, Sum, Avg, Max, Min 등)은 having절과 함께 사용할 수 있으나,

where절은 사용할 수 없다.(집계함수를 사용할 수 있는 group by 절보다 where절이 먼저 수행)

- having은 그룹화 또는 집계가 발생한 후 필터링하는데 사용되고,
- where은 그룹화 또는 집계가 발생하기 전에 필터링하는데 사용된다.

### JOIN에서 ON과 WHERE의 차이를 설명

- ON이 WHERE보다 먼저 실행되어 JOIN을 하기 전에 필터링을 하고 (=ON 조건으로 필터링이 된 레코드들간 JOIN이 이뤄진다)
- WHERE은 JOIN을 한 후에 필터링을 한다.(=JOIN을 한 결과에서 WHERE조건절로 필터링이 이뤄진다.)
